# 2020/09

## 02
[C\# \- 開いているエクスプローラのパスを一覧表示する \- Qiita](https://qiita.com/kob58im/items/69b4b9e6d4ff52802abb)

参考資料  
[夕暮ログ エクスプローラ\(Explorer\.EXE\)で開いているフォルダのパスを取得する](http://tinqwill.blog59.fc2.com/blog-entry-84.html)

[URIのローカルファイルパスをWindowsのパス形式に変換する \- \.NET Tips \(VB\.NET,C\#\.\.\.\)](https://dobon.net/vb/dotnet/file/uritofilepath.html)

### このPGの目的
エクスプローラを開き過ぎた際に、表形式で開いているエクスプローラのパスを表示。  
ダブルクリックするとウィンドウを最前面に表示する。

### PG内容
ListUpFileExplorerは一覧表示用のメインメソッドで  
ここから開いているエクスプローラのパスを取得するReloadListメソッドや一覧の明細部分ダブルクリックで対象画面を最前面に表示するLsv_DoubleClickメソッドなどを呼び出しで実行する

```c#
using System;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

class ListUpFileExplorer : Form
{
    ListView lsv;

    class NativeMethods
    {
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool SetForegroundWindow(IntPtr hWnd);

        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool IsIconic(IntPtr hWnd);

        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        public const int SW_RESTORE = 9;

        //[DllImport("user32.dll", SetLastError = true)]
        //public static extern int GetWindowThreadProcessId(IntPtr hWnd, out int lpdwProcessId);
    }

    ListUpFileExplorer()
    {
        Text = "List up File Explorer";
        ClientSize = new Size(960,250);


        var btn = new Button(){
            Location = new Point(0,0),
            Size = new System.Drawing.Size(100,25),
            Text = "Reload",
        };
        btn.Click += (s,e)=>{ReloadList();};
        Controls.Add(btn);


        Controls.Add(lsv = new ListView(){
            Location = new Point(0,30),
            Size = new System.Drawing.Size(700,200),
            View = View.Details,
            FullRowSelect = true,
            GridLines = true,
        });
        lsv.Columns.Add("Name", 150, HorizontalAlignment.Left);
        lsv.Columns.Add("Path", 800, HorizontalAlignment.Left);
        lsv.DoubleClick += (s,e)=>{Lsv_DoubleClick();};
        var cms = new ContextMenuStrip();
        cms.Opening += Cms_Opening;
        cms.Items.Add(new ToolStripMenuItem("Copy Text", null, (s,e)=>{CopySelectedItemText();}, Keys.Control | Keys.C));
        lsv.ContextMenuStrip = cms;

        ReloadList();

        Load += (s,e)=>{Form_Resize();};
        Resize += (s,e)=>{Form_Resize();};
        ResizeEnd += (s,e)=>{Form_Resize();};
    }

    void ReloadList()
    {   
        {
            lsv.Items.Clear();
            lsv.BeginUpdate();
            try {
                Type comShellType = Type.GetTypeFromProgID("Shell.Application");
                dynamic shell = Activator.CreateInstance(comShellType);

                dynamic windows = shell.Windows();

                foreach (dynamic win in windows) {
                    //エクスプローラのみ(IEを除外)
                    string tmp = win.FullName;
                    if (String.Compare(Path.GetFileName(tmp), "EXPLORER.EXE", true)==0) { // 大文字小文字無視で比較
                        string webUri = win.LocationURL;
                        if ( webUri != "" ) {
                            Uri u = new Uri(webUri);
                            if (u.IsFile) {
                                //Windows形式のパス表現に変換する
                                string path = u.LocalPath + Uri.UnescapeDataString(u.Fragment);
                                var item = new ListViewItem(new string[]{Path.GetFileName(path),path});
                                long hwndValue = win.HWND;
                                item.Tag = new IntPtr(hwndValue);
                                lsv.Items.Add(item);
                            }
                        }
                    }
                }
            }
            finally{
                lsv.EndUpdate();
            }
        }

        // COMオブジェクト解放 ... これでいいはず
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }

    void Cms_Opening(object sender, CancelEventArgs e)
    {
        Point p = lsv.PointToClient(Cursor.Position);
        var item = lsv.HitTest(p).Item;
        if ( item == null ) {
            e.Cancel = true;
        }
        else if ( item.Bounds.Contains(p) ) {
        }
        else {
            e.Cancel = true;
        }
    }

    void CopySelectedItemText()
    {
        var indices = lsv.SelectedIndices;

        if ( indices.Count == 1 ) {
            string path = lsv.Items[indices[0]].SubItems[1].Text;
            Clipboard.SetText(path);
        }
    }

    void Lsv_DoubleClick()
    {
        var indices = lsv.SelectedIndices;

        if ( indices.Count == 1 ) {
            var hwnd = (IntPtr)(lsv.Items[indices[0]].Tag);

            //int pid;
            //NativeMethods.GetWindowThreadProcessId(hWnd, out pid);
            //Process p = Process.GetProcessById(pid);

            if ( NativeMethods.IsIconic(hwnd) ){
                // 最小化から戻す
                NativeMethods.ShowWindow(hwnd, NativeMethods.SW_RESTORE);
            }

            if ( ! NativeMethods.SetForegroundWindow(hwnd) ) {
                // フォーカス移動失敗
            }
        }
    }

    void Form_Resize()
    {
        int h = ClientSize.Height - lsv.Top;
        if(h<=10){h=10;}
        lsv.Size = new Size(ClientSize.Width,h);
    }

    [STAThread]
    static void Main(string[] args)
    {
        Application.Run(new ListUpFileExplorer());
    }
}

```

### ReloadListメソッド
開いている状態のエクスプローラの一覧を取得するメソッド。
```c#
    void ReloadList()
    {   
        {
            lsv.Items.Clear();
            lsv.BeginUpdate();
            try {
                Type comShellType = Type.GetTypeFromProgID("Shell.Application");
                dynamic shell = Activator.CreateInstance(comShellType);

                dynamic windows = shell.Windows();

                foreach (dynamic win in windows) {
                    //エクスプローラのみ(IEを除外)
                    string tmp = win.FullName;
                    if (String.Compare(Path.GetFileName(tmp), "EXPLORER.EXE", true)==0) { // 大文字小文字無視で比較
                        string webUri = win.LocationURL;
                        if ( webUri != "" ) {
                            Uri u = new Uri(webUri);
                            if (u.IsFile) {
                                //Windows形式のパス表現に変換する
                                string path = u.LocalPath + Uri.UnescapeDataString(u.Fragment);
                                var item = new ListViewItem(new string[]{Path.GetFileName(path),path});
                                long hwndValue = win.HWND;
                                item.Tag = new IntPtr(hwndValue);
                                lsv.Items.Add(item);
                            }
                        }
                    }
                }
            }
            finally{
                lsv.EndUpdate();
            }
        }

        // COMオブジェクト解放 ... これでいいはず
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }

```

```c#
dynamic windows = shell.Windows();
```
この部分で開いているIEとエクスプローラの一覧を取得している。

```c#
foreach (dynamic win in windows) {
    //エクスプローラのみ(IEを除外)
    string tmp = win.FullName;
    if (String.Compare(Path.GetFileName(tmp), "EXPLORER.EXE", true)==0) { // 大文字小文字無視で比較
        string webUri = win.LocationURL;
        if ( webUri != "" ) {
            Uri u = new Uri(webUri);
            if (u.IsFile) {
                //Windows形式のパス表現に変換する
                string path = u.LocalPath + Uri.UnescapeDataString(u.Fragment);
                var item = new ListViewItem(new string[]{Path.GetFileName(path),path});
                long hwndValue = win.HWND;
                item.Tag = new IntPtr(hwndValue);
                lsv.Items.Add(item);
            }
        }
    }
}
```
取得した一覧からエクスプローラのみの情報を取得してパス(場所)として変換している。

## 03
[Try Catch文がとらえるのは"例外"である \- Qiita](https://qiita.com/yuu_j/items/fed8f687216ef471bc97)

### 問題のPG
例外が頻繁に発生してしまう。
```c#
    try
    {
　　　　　# a,b共に、nullになる可能性がある
        var a = GetA();
        var b = GetB();
        # 変数bのnullチェックはしていない
        if(a != null)
        {
            var aHoge = a.GetHoge();
            var bHoge = b.GetHoge();
        }
    }
    catch
    {}
```
Try Catch文はTry{}内部に記述した関数などで例外が発生した際に  
Catchで例外ダイアログを表示する。  
問題は変数bがnullの状態でGetHoge関数を実行して例外が発生し、Try Catchで例外を掴む。  
例外の発生する要因となるのはa,bの二つの変数だけなのでわざわざTry Catch文を使用して使わずとも変数bのnullチェックも行えば良い。


## 04
[C\#を使って秘密鍵と公開鍵で暗号・復号 \- Qiita](https://qiita.com/piyo8810/items/7f1a767fa78d87930cba)

参考  
[c\#の暗号化クラスを使ってみた（AES,RSA） \- Qiita](https://qiita.com/kz-rv04/items/62a56bd4cd149e36ca70)

[データの暗号化 \| Microsoft Docs](https://docs.microsoft.com/ja-jp/dotnet/standard/security/encrypting-data)

### 文字列の暗号化・復号化
以下の条件での暗号化と復号化。

1. サーバーが秘密鍵と公開鍵を発行する。
2. クライアントに文字列で公開鍵情報を渡す。
3. クライアントは公開鍵情報を使ってデータを暗号化、サーバーに送付。
4. サーバーは秘密鍵情報を使ってデータを復号。

### PG

```c#
namespace RsaConsole
{
    class Program
    {
        static void Main(string[] args)
        {
            // 暗号化したい文字列をバイト配列に変換
            string encryptWord = "冷やし中華ｧァ～";
            var encByte = Encoding.Unicode.GetBytes(encryptWord);

            // 秘密鍵と公開鍵を生成
            RSA rsa = RSA.Create();

            // 鍵情報を保存
            var publicKey = rsa.ToXmlString(false);
            var privateKey = rsa.ToXmlString(true);

            // 公開鍵情報の文字列からオブジェクトを復元
            byte[] encryptedByte;
            using (RSA encRsa = RSA.Create())
            {
                encRsa.FromXmlString(publicKey);
                encryptedByte = encRsa.Encrypt(encByte, RSAEncryptionPadding.Pkcs1);
            }

            // 暗号化したバイトデータを16進数文字列に変換
            var encByteToString = BitConverter.ToString(encryptedByte);
            Console.WriteLine($"Encrypt: {encByteToString}");

            // 
            // 上記の方法で生成された16進数文字列を外部から受信したと仮定して、
            // 秘密鍵を使って復元する
            //

            // 送信されてきた文字列をバイト配列に変換
            var encStrToBytes = encByteToString.Split('-').Select(r => Convert.ToByte(r, 16)).ToArray();
            byte[] decryptedByte;

            // 秘密鍵情報の文字列からオブジェクトを復元し、復号
            using (RSA decRsa = RSA.Create())
            {
                decRsa.FromXmlString(privateKey);
                decryptedByte = decRsa.Decrypt(encStrToBytes, RSAEncryptionPadding.Pkcs1);
            }

            var decryptedString = Encoding.Unicode.GetString(decryptedByte);

            Console.WriteLine($"Decrypt: {decryptedString}");

            // 試しにテキトーな鍵で復号してみる
            var invalidDec = string.Empty;
            try
            {
                using (RSA invalidRsa = RSA.Create())
                {
                    decryptedByte = invalidRsa.Decrypt(encStrToBytes, RSAEncryptionPadding.Pkcs1);
                }
            }
            catch
            {
                Console.WriteLine("Failed to decrypt.");
            }

            return;
        }
    }
}
```

文字列をバイト配列にすることで暗号化している。
```c#
// 暗号化したい文字列をバイト配列に変換
string encryptWord = "冷やし中華ｧァ～";
var encByte = Encoding.Unicode.GetBytes(encryptWord);
```
また鍵の作成には**非対称暗号化**に使用されるRSAクラスを使用する。  
このとき作成した鍵は、公開鍵と秘密鍵に分けて保存する。
```c#
// 秘密鍵と公開鍵を生成
RSA rsa = RSA.Create();

// 鍵情報を保存
var publicKey = rsa.ToXmlString(false);
var privateKey = rsa.ToXmlString(true);
```
公開鍵を使用した暗号の復元。  
RSAクラスのEncrypt関数で復号化している。
```c#
// 公開鍵情報の文字列からオブジェクトを復元
byte[] encryptedByte;
using (RSA encRsa = RSA.Create())
{
    encRsa.FromXmlString(publicKey);
    encryptedByte = encRsa.Encrypt(encByte, RSAEncryptionPadding.Pkcs1);
}
```

### 不明点
・文字列の復号化の部分の理解が甘い
```c#
// RSA.Create？なぜ再度鍵を生成しているのか
using (RSA encRsa = RSA.Create())
{
    encRsa.FromXmlString(publicKey);
    encryptedByte = encRsa.Encrypt(encByte, RSAEncryptionPadding.Pkcs1);
}
```

## 07
[【JavaScript】String配列の要素をキーとするオブジェクトを作成する方法 \- Qiita](https://qiita.com/impl_s/items/5b067e15181e0ad95bd0)

参考資料  
[JavaScriptの基本である連想配列をマスターする｜TECH PLAY Magazine ［テックプレイマガジン］](https://techplay.jp/column/528)

### 配列と連想配列
配列はキーと値を持つ要素の集合で、一般的な配列は特にキーを指定しない場合は0から始まる自然数が自動的に割り当てられる。  

連想配列は任意のキーを割り当てて共に数値を代入する配列で、キーの名前を元にして中身の数値が何であるか連想できる配列。

### ループを使用してた連想配列の作成
for eachメソッドでキーの要素分ループを行い、key1から順番に対応する値を代入を行っている。

```c#
const array = ['key1', 'key2', 'key3',]

const createObj = (array) => {
    const obj = new Object();
    array.forEach(item => (Object.defineProperty(obj, item, {
      enumerable: true, // ループのために必要!
      value: 'ここに値'
    })));
    return obj;
}

// 配列内容の出力
console.log(createObj(array));
// {key1: 'ここに値', key2: 'ここに値', key3: 'ここに値'}
```

## 08
[コピペで簡単！NLogをすぐに使えるようにしたい人へ \- Qiita](https://qiita.com/hiesiea/items/f45e06d7c09dcd6577cf)

参考資料  
[C\# NLog チュートリアル \- Qiita](https://qiita.com/developpermanati/items/1de20d836070f42049cf)

[NLogでログを記録する \- Qiita](https://qiita.com/hsagae/items/9f09e6ee204745fd2481)

### Nlogとは
.NET Frameworkを使っていてログを記録するときに使用できるライブラリ。

自環境にインストールして使用。

### 表示できるもの
- Trace
  - プロトコルのペイロードなど大量で詳細なデータを出力するときに使用する。開発中のみ有効
- Debug
  - Traceレベルよりも詳細ではないデバック中のログを出力するときに使用する。開発中のみ有効
- Info
  - 情報メッセージ。稼働環境で有効
- Warn
  - 警告メッセージ。回復可能であるか、または一時的な障害に関する警告メッセージを出力する。
- Error
  - エラーメッセージ。Exseption情報を出力する。
- Fatal
  - 非常に重大なエラーメッセージ。

### まとめ
ログファイルの出力を簡単に実行することができるようになる。