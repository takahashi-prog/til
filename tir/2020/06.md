# 2020/6

## 01
[C\# Linqを使ったら超便利だった\#1 \- Qiita](https://qiita.com/p1ro3/items/58da3f47975b301ae75f)

リストや配列に入ったデータの操作が容易になり、行数が減り、コード全体が見やすくなる。

リスト型変数
```c#
List<int> source = new List<int>() { 1, 2, 3, 4, 5, 6 };
```

変数内の要素を表示する(通常)
```c#
foreach(int num in source)
{
    Console.WriteLine(num);
}
```

変数内の要素を表示する(Linq)
```c#
source.ForEach(delegate (int num){ Console.WriteLine(num); });
```


ループを回さなくとも表示処理を一行で実行することが可能になる。

1. ForEach
  要素全てを探索する
2. Where
  一致するデータの抽出

### 不明な点
1. delegate

## 02
[【LINQの前に】ラムダ式？デリゲート？Func<T, TResult>？な人へのまとめ【知ってほしい】 \- Qiita](https://qiita.com/RyotaMurohoshi/items/740151bd772889cf07de)

### delegateとは
メソッドを参照するデータ型で、delegateを介してメソッドを引数として渡すことや返り値として返すことができる。  

### 重要な点
- delegateという機能
- 外からパラメーターとして処理を注入している。
- 中から外を呼び出している。

```c#
public static void Main(string[] args){
  var list = Enumerable.Range(1,10);
  var result = Pow2(list,logger)
}
public delegate void logger(int i){
  Console.WriteLine($"{i} x {i} = {i*i}");
}
public delegate void nullLogger(int i){
  //
}
public delegate void formLogger(int i){
  textBox1.Text += $"{i} x {i} = {i*i}";
}

// Action<T> : 戻り値がない
// Function<T,TResult> : 戻り値がTResult

public IEnumerable<int> Pow2(IEnumerable<int> list,Action<int> logger){
  var result = new List<int>();
  foreach (var i in list){
    result.Add(i*i);
    logger(i);
  }
  return result ;
}
```

----
```c#
public static void Main(string[] args){
  var list = Enumerable.Range(1,10);
  var result = Calc(list,divide3)
}
public int power(int i) {
  return i*i ;
}
public int divide3(int i) {
  return (int)(i/3) ;
}
public int double(int i) {
  return (int)(i*2) ;
}
// Action<sting,int,double,decimal> 
// Func<sting,int,double,decimal> 

public IEnumerable<int> Calc(IEnumerable<int> list,Func<int,int> calculator){
  var result = new List<int>();
  foreach (var i in list){
    result.Add(calculator(i));
  }
  return result ;
}

```
### 利点
上記のCalcメソッドのような一つの処理に外からメソッドを渡すことで  
共用することができ、長いコードを書く必要がなくなる。  
また、リストに対する計算機能が外にあるためCalcメソッドの信頼性を保ったまま、より短いコード量でカスタマイズが可能になる。

### 不明な点
1. クラスメソッドとインスタンスメソッドの違い

## 03
[【C\#】わかった"つもり"になれる「ラムダ式」解説 \- Qiita](https://qiita.com/toRisouP/items/98cc4966d392b7f21c30)

### ラムダ式とは
対象の関数をラムダ式に置き換えて記述を省略するためのもの。

(引数の変数) → {関数本体}  

上記の様に関数を定義を省略して内部の処理を実行することができる。

### 使用方法
ラムダ式で作った関数は必ずデリゲートに代入して使う

**いずれ記事修正を予定**

## 04
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第2章 P35～P38

### 理解した部分

現実世界 = オブジェクト指向ではない。

オブジェクト指向の基本はクラスでインスタンスはクラスの対となる要素となっている。  クラス(同種のものの集まり)を元にインスタンス(実例)を生成している。

### 不明な点
1. ポリモーフィズム
2. 

## 05
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第2章 P39～P42

### 理解した部分

``` java
class Animal {
  abstract String cry();
}
```
ポリモーフィズムの説明に使用されているJavaのabstractは抽象メソッドを使用するためのもの。  

ポリモーフィズムとはメッセージの送り方を共通にするためのもの。

### 継承
継承とはクラスの共通点をまとめたり、相違点を整理するためのもの。

- スーパークラス(全体集合)
- サブクラス(部分集合)

スーパークラスに共通処理を記述し、サブクラスには固有処理を記述する流れとなる。

### 不明な点
1. ポリモーフィズムの説明サンプルPGの動作  
   - 次回実際に作成して動作確認を予定

## 08
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第2章 P42～P49

### スーパークラスとサブクラス
スーパークラスとサブクラスは親と子の関係。  
子は親の機能を持っていて、子が独自に作り出した機能のことは親は知らない。

### ポリモーフィズム
ポリモーフィズム = 呼び出しかたを共通にする。  
大事なことは複数の対象の共通部を同じ呼び出し方で実装させたいという目的があって、ポリモーフィズムを使用しているということ。

### abstract
抽象クラスと抽象メソッドに使用するキーワード。  
自身のサブクラスが共通のメソッドを持っているという制約を持つという意味を持つ。  
持っていない場合はエラーとなる。

### 親と子の継承と型の関係
ある親を継承した場合に子は、親のクラス型であり子のクラス型でもあるという状態になる。  
共通の親クラスを持つ子クラスは**親クラス型の変数でインスタンスを受け取ることが出来る**  
この関係とabstractを使用したメソッドの抽象化で、メソッドの実装部をサブクラスで個別に行うことで呼出し方を同じにすることができる。

スーパークラス
```c#
    abstract class Animal
    {
        // 抽象メソッド(サブクラスで共通名のメソッドを使用するという制約をかける)
        public abstract string Cry();

        // クラス型表示用処理
        public string ClassName()
        {
            return this.GetType().Name;
        }

    }
```

サブクラス
```c#
    // Animalを継承した鳥の鳴き声を返すBirdクラス
    class Bird : Animal
    {
        public override string Cry()
        {
            return "ピヨピヨ";
        }
        public string Fly()
        {
            return "I can fly.";
        }

    }
    // Animalを継承した犬の鳴き声を返すDogクラス
    class Dog : Animal
    {
        public override string Cry()
        {
            return "ワン";
        }
    }
```

呼出し部分
```c#
            var seed = new Random().Next();
            Animal animal;

            // Birdクラスを元にインスタンスを生成する
            if (seed % 2 == 0)
            {
                animal = new Bird();
            }
            else
            {
                animal = new Dog();
            }

            // 鳴き声とクラスの表示
            Console.WriteLine(animal.ClassName());
            Console.WriteLine(animal.Cry());
            Console.ReadLine();
```
ランダムにseed変数に数字を入れて偶数は鳥、奇数は犬として分岐して鳴き声と自分のクラス型を表示する。  
BirdクラスとDogクラスは同じAnimalクラスを親に持っているため、Animal型で生成したインスタンスを受け取って共通メソッド実行することができる。


呼出し部分(親または子クラス型別にインスタンス生成ver)
``` c#
            // Birdクラスを元にインスタンスを生成する
            Bird bird = new Bird();
            bird.Fly();//1
            
            // Animalクラスを元にインスタンスを生成する
            Animal animal = new bird();
            animal.Fly(); //2

            // 鳴き声の表示
            Console.WriteLine(animal.Cry());
```
1の様に子自身のクラス型でインスタンスを受け取った場合は子独自のFlyメソッドを呼び出すことが可能です。  
2の様に親のクラス型でインスタンスを受け取った場合はFlyメソッド呼出しはエラーとなる。  
しかし、abstractを使用して共通化したメソッドは1と2どちらの場合でも実行することができる。

### なぜ何でもオブジェクトで例えるべきではないのか
オブジェクト指向ではモノは一つのクラスに属していて、それ以降変化することはない。しかし、現実世界のモノは見方や状況によって所属するクラスが変化する。そのためオブジェクト指向を正しく捉えるためには  
現実世界 = オブジェクト指向は控えるべきだ。

## 09
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第3章 P55～P59
OOP(オブジェクト指向プログラミング言語)を理解するにはプログラミング言語の歴史を知る必要がある。

### OOPの生まれ
OOPは現実世界にそって生まれたのではなく、昔のプログラミング言語を発展させて欠点を克服した言語。

### プログラミング言語の進化の流れ
1. 機械語
2. アセンブリ言語
3. 高級言語
4. 構造化プログラミング言語

### 機械語
コンピュータのみが理解することができる2進数で書かれた言語。  
初めの頃は人間が直接機械語を使って一行一行命令を記述していた。

### アセンブリ言語
機械語を更に発展させ、機械語を人間に理解することのできる記号に置き換えた言語。  
ADDやMOVなど単語単位で加算や移動を行っているのがわかる。

### 高級言語
機械語とアセンブリ言語ではコンピュータに一つひとつ実行命令を記述していたが、それをより分かりやすい形式で表現した言語。

### 不明な点
- FORTRAN

## 10
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

[構造化プログラミング \- Wikipedia](https://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)
### 第3章 P59～P61
OOP(オブジェクト指向プログラミング)を理解するにはプログラミング言語の歴史を知る必要がある。

### 構造化プログラミングとは
以前までのプログラミング言語ではGOTO文が多用されていて処理が飛び飛びになっていて可読性が非常に低かった。  
そのGOTO文を廃止し、基本三構造で分かり易く表現する手法のこと。GOTOレスプログラミングとも呼ばれる。

#### 基本三構造
1. 順次進行
2. 条件分岐
3. 繰り返し

### なぜ構造化前はGOTO文が多用されていたか
昔はPCスペックが低く、容量を圧迫しないようにロジックも短く記述する必要があった。そのためGOTO文などが多用されてスパゲッティコードが沢山生まれた。

### 注意点
1. オブジェクト指向
2. オブジェクト指向プログラム
3. オブジェクト指向プログラミング言語

1は考え方、2は書き方、3はオブジェクト指向が機能(継承やカプセル化など)として使用できる言語

## 11
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第3章 P61～P64
OOP(オブジェクト指向プログラミング)を理解するにはプログラミング言語の歴史を知る必要がある。

### 高級言語以降に生まれた技術
1. 構造化プログラミング
2. サブルーチン(関数)の独立

### なぜサブルーチンの独立性を高めるのか
構造化プログラミングはコードを分かりやすくするための手法。  
サブルーチンの独立性を高める目的はプログラムの保守をしやすくするため。

### サブルーチンの独立させる方法
まずプログラムには大きく分けてメインルーチンとサブルーチンがある。メインは呼び出し側のことでサブは関数などのこと。  
当時は複数のサブルーチンから共通のグローバル変数を使用していて、どのサブルーチンがグローバル変数に変更を加えたのか理解し辛く、意図しない他関数の代入などで不具合が発生した。  
このことから呼び出し側と関数の共有する情報を少なくする方法が必要になり、ローカル変数と引数の値渡しが生まれた。
ローカル変数は関数に入ったときに生まれて内部で使用されて関数を抜けるときに消える。
引数の値渡しは呼び出し側の参照している値を直接使用しないで、コピーして関数で使用する

## 12
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第3章 P64～P65
OOP(オブジェクト指向プログラミング)を理解するにはプログラミング言語の歴史を知る必要がある。

### 構造化言語の登場
構造化プログラムを作成するための機能が基本機能として備わっている標準化言語が登場した。if、case、while、forなどを使って上から下へ処理の分岐などを行って分かりやすいコードを作ることができるようになった。

### 構造化言語の種類
1. ALGOL
2. Pascal
3. C言語

### 不明な点
- C言語の特徴
- プログラミングに必要な機能を**言語仕様**で提供する言語、**関数ライブラリ**で提供する言語

## 15
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第3章 P65～P71
OOP(オブジェクト指向プログラミング)を理解するにはプログラミング言語の歴史を知る必要がある。

### プログラミング言語の進化の目的
機械語→アセンブリ言語→高級言語までの進化の目的は生産性を向上するさせ、20世紀には総人口がプログラマになっても生産が追いつかないというソフトウェア危機に対処するため。  
構造化言語はプログラムの保守性を高めて、毎回1からプログラムを作成するのではなく既存のプログラムを修正することで開発しやすくするのが目的。

### 構造化言語でも解決出来なかった問題
1. グローバル変数問題
2. 貧弱な再利用問題

#### グローバル変数問題
ローカル変数や値渡しを用いた構造化ではサブルーチンを抜けた場合に変数が消えてしまうので、サブルーチン外で常に持っておきたい値などはやむを得ずグローバル変数にするしかなかった。

#### 貧弱な再利用問題
共通部品化できるのはサブルーチンだけであったため、再利用できる範囲が狭かった。

### 不明な点
- 西暦2000年問題

## 16
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第4章 P77～P78
OOP(オブジェクト指向プログラミング)は無駄を省き、整理整頓するための書き方。

### OOPが持つ3つの仕組み
1. クラス
2. ポリモーフィズム
3. 継承

この仕組みは、グローバル変数を使わず、  
共通サブルーチン以外の再利用を可能にするために使用している。

### クラスの使用方法
主にカプセル化に使用される。  
カプセル化には内容を隠ぺいすることでセキュリティ面でプログラムを強化する側面と  
クラス内でクラス変数を持ち、外から触れない様にするなど  
責任範囲をクラス内に絞ることでこれまでグローバル変数で持っていた状態変数を扱うことができる。

## 17
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第4章 P78～P81
OOP(オブジェクト指向プログラミング)は無駄を省き、整理整頓するための書き方。

### ポリモーフィズムと継承
共通関数では対処できない重複コードを一つにまとめるためのもの。

### OOPの仕組みの狙い
共通部分はまとめて、何度も記述しないことでコードの文章量を減らし、  
入力ミスをなくす。カスタマイズしやすくする。

### クラスの3つの役割
1. サブルーチンと変数を「まとめる」
2. クラスの内部だけで使う変数やサブルーチンを「隠す」
3. 1つのクラスからインスタンスを「たくさん作る」

## 18
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第4章 P81～P
OOP(オブジェクト指向プログラミング)は無駄を省き、整理整頓するための書き方。

### クラスを使ってサブルーチンと変数をまとめる
構造化プログラミングで記述したファイルアクセス処理
```java

// アクセス中のファイル番号を格納するグローバル変数
int fileNo;

// ファイルを開く
// (引数にパスを受け取る)
void openFile(String pathName){ /*ロジックは省略*/ }

// ファイルを閉じる
void closeFile(){ /*ロジックは省略*/ }

// ファイルを読み込む
char readFile(){ /*ロジックは省略*/ }

```

今までは構造化でサブルーチン(関数)単位でしか処理の整理ができなかったが、  
クラスを使用することで複数のサブルーチンや変数もまとめることが出来るようになった。  

OOPで記述したファイルアクセス処理
```java

class TextFileReader {

  // アクセス中のファイル番号を格納するグローバル変数
  int fileNo;

  // ファイルを開く
  // (引数にパスを受け取る)
  void openFile(String pathName){ /*ロジックは省略*/ }

  // ファイルを閉じる
  void closeFile(){ /*ロジックは省略*/ }

  // ファイルを読み込む
  char readFile(){ /*ロジックは省略*/ }
}

```
OOPでは  
クラスにまとめられたサブルーチンを**メソッド**と呼ぶ。  
クラスにまとめられた変数は**インスタンス変数**と呼ぶ。

### 「まとめる」ことの利点
複数のサブルーチンをまとめることで部品が少なくなり、  
部品を探しているときに見つけやすくなる。

クラスでもってサブルーチンをまとめているので、  
クラス自体にどんな処理であるか名づけることができる。  
そのため事前にクラスが名前で持って処理の説明をしてくれているので、  
自然とクラス内に含まれるサブルーチン自体の名前も短くなる。

### 不明な点
- インスタンス
  - クラス(設計図)を元に生成される実体のこと。

- インスタンス変数
  - クラス内での変数をインスタンス変数と呼ぶ。