# 2020/6

## 01
[C\# Linqを使ったら超便利だった\#1 \- Qiita](https://qiita.com/p1ro3/items/58da3f47975b301ae75f)

リストや配列に入ったデータの操作が容易になり、行数が減り、コード全体が見やすくなる。

リスト型変数
```c#
List<int> source = new List<int>() { 1, 2, 3, 4, 5, 6 };
```

変数内の要素を表示する(通常)
```c#
foreach(int num in source)
{
    Console.WriteLine(num);
}
```

変数内の要素を表示する(Linq)
```c#
source.ForEach(delegate (int num){ Console.WriteLine(num); });
```


ループを回さなくとも表示処理を一行で実行することが可能になる。

1. ForEach
  要素全てを探索する
2. Where
  一致するデータの抽出

### 不明な点
1. delegate

## 02
[【LINQの前に】ラムダ式？デリゲート？Func<T, TResult>？な人へのまとめ【知ってほしい】 \- Qiita](https://qiita.com/RyotaMurohoshi/items/740151bd772889cf07de)

### delegateとは
メソッドを参照するデータ型で、delegateを介してメソッドを引数として渡すことや返り値として返すことができる。  

### 重要な点
- delegateという機能
- 外からパラメーターとして処理を注入している。
- 中から外を呼び出している。

```c#
public static void Main(string[] args){
  var list = Enumerable.Range(1,10);
  var result = Pow2(list,logger)
}
public delegate void logger(int i){
  Console.WriteLine($"{i} x {i} = {i*i}");
}
public delegate void nullLogger(int i){
  //
}
public delegate void formLogger(int i){
  textBox1.Text += $"{i} x {i} = {i*i}";
}

// Action<T> : 戻り値がない
// Function<T,TResult> : 戻り値がTResult

public IEnumerable<int> Pow2(IEnumerable<int> list,Action<int> logger){
  var result = new List<int>();
  foreach (var i in list){
    result.Add(i*i);
    logger(i);
  }
  return result ;
}
```

----
```c#
public static void Main(string[] args){
  var list = Enumerable.Range(1,10);
  var result = Calc(list,divide3)
}
public int power(int i) {
  return i*i ;
}
public int divide3(int i) {
  return (int)(i/3) ;
}
public int double(int i) {
  return (int)(i*2) ;
}
// Action<sting,int,double,decimal> 
// Func<sting,int,double,decimal> 

public IEnumerable<int> Calc(IEnumerable<int> list,Func<int,int> calculator){
  var result = new List<int>();
  foreach (var i in list){
    result.Add(calculator(i));
  }
  return result ;
}

```
### 利点
上記のCalcメソッドのような一つの処理に外からメソッドを渡すことで  
共用することができ、長いコードを書く必要がなくなる。  
また、リストに対する計算機能が外にあるためCalcメソッドの信頼性を保ったまま、より短いコード量でカスタマイズが可能になる。

### 不明な点
1. クラスメソッドとインスタンスメソッドの違い

## 03
[【C\#】わかった"つもり"になれる「ラムダ式」解説 \- Qiita](https://qiita.com/toRisouP/items/98cc4966d392b7f21c30)

### ラムダ式とは
対象の関数をラムダ式に置き換えて記述を省略するためのもの。

(引数の変数) → {関数本体}  

上記の様に関数を定義を省略して内部の処理を実行することができる。

### 使用方法
ラムダ式で作った関数は必ずデリゲートに代入して使う

**いずれ記事修正を予定**

## 04
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第2章 P35～P38

### 理解した部分

現実世界 = オブジェクト指向ではない。

オブジェクト指向の基本はクラスでインスタンスはクラスの対となる要素となっている。  クラス(同種のものの集まり)を元にインスタンス(実例)を生成している。

### 不明な点
1. ポリモーフィズム
2. 

## 05
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第2章 P39～P42

### 理解した部分

``` java
class Animal {
  abstract String cry();
}
```
ポリモーフィズムの説明に使用されているJavaのabstractは抽象メソッドを使用するためのもの。  

ポリモーフィズムとはメッセージの送り方を共通にするためのもの。

### 継承
継承とはクラスの共通点をまとめたり、相違点を整理するためのもの。

- スーパークラス(全体集合)
- サブクラス(部分集合)

スーパークラスに共通処理を記述し、サブクラスには固有処理を記述する流れとなる。

### 不明な点
1. ポリモーフィズムの説明サンプルPGの動作  
   - 次回実際に作成して動作確認を予定

## 08
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第2章 P42～P49

### スーパークラスとサブクラス
スーパークラスとサブクラスは親と子の関係。  
子は親の機能を持っていて、子が独自に作り出した機能のことは親は知らない。

### ポリモーフィズム
ポリモーフィズム = 呼び出しかたを共通にする。  
大事なことは複数の対象の共通部を同じ呼び出し方で実装させたいという目的があって、ポリモーフィズムを使用しているということ。

### abstract
抽象クラスと抽象メソッドに使用するキーワード。  
自身のサブクラスが共通のメソッドを持っているという制約を持つという意味を持つ。  
持っていない場合はエラーとなる。

### 親と子の継承と型の関係
ある親を継承した場合に子は、親のクラス型であり子のクラス型でもあるという状態になる。  
共通の親クラスを持つ子クラスは**親クラス型の変数でインスタンスを受け取ることが出来る**  
この関係とabstractを使用したメソッドの抽象化で、メソッドの実装部をサブクラスで個別に行うことで呼出し方を同じにすることができる。

スーパークラス
```c#
    abstract class Animal
    {
        // 抽象メソッド(サブクラスで共通名のメソッドを使用するという制約をかける)
        public abstract string Cry();

        // クラス型表示用処理
        public string ClassName()
        {
            return this.GetType().Name;
        }

    }
```

サブクラス
```c#
    // Animalを継承した鳥の鳴き声を返すBirdクラス
    class Bird : Animal
    {
        public override string Cry()
        {
            return "ピヨピヨ";
        }
        public string Fly()
        {
            return "I can fly.";
        }

    }
    // Animalを継承した犬の鳴き声を返すDogクラス
    class Dog : Animal
    {
        public override string Cry()
        {
            return "ワン";
        }
    }
```

呼出し部分
```c#
            var seed = new Random().Next();
            Animal animal;

            // Birdクラスを元にインスタンスを生成する
            if (seed % 2 == 0)
            {
                animal = new Bird();
            }
            else
            {
                animal = new Dog();
            }

            // 鳴き声とクラスの表示
            Console.WriteLine(animal.ClassName());
            Console.WriteLine(animal.Cry());
            Console.ReadLine();
```
ランダムにseed変数に数字を入れて偶数は鳥、奇数は犬として分岐して鳴き声と自分のクラス型を表示する。  
BirdクラスとDogクラスは同じAnimalクラスを親に持っているため、Animal型で生成したインスタンスを受け取って共通メソッド実行することができる。


呼出し部分(親または子クラス型別にインスタンス生成ver)
``` c#
            // Birdクラスを元にインスタンスを生成する
            Bird bird = new Bird();
            bird.Fly();//1
            
            // Animalクラスを元にインスタンスを生成する
            Animal animal = new bird();
            animal.Fly(); //2

            // 鳴き声の表示
            Console.WriteLine(animal.Cry());
```
1の様に子自身のクラス型でインスタンスを受け取った場合は子独自のFlyメソッドを呼び出すことが可能です。  
2の様に親のクラス型でインスタンスを受け取った場合はFlyメソッド呼出しはエラーとなる。  
しかし、abstractを使用して共通化したメソッドは1と2どちらの場合でも実行することができる。

### なぜ何でもオブジェクトで例えるべきではないのか
オブジェクト指向ではモノは一つのクラスに属していて、それ以降変化することはない。しかし、現実世界のモノは見方や状況によって所属するクラスが変化する。そのためオブジェクト指向を正しく捉えるためには  
現実世界 = オブジェクト指向は控えるべきだ。

## 09
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第3章 P55～P59
OOP(オブジェクト指向プログラミング言語)を理解するにはプログラミング言語の歴史を知る必要がある。

### OOPの生まれ
OOPは現実世界にそって生まれたのではなく、昔のプログラミング言語を発展させて欠点を克服した言語。

### プログラミング言語の進化の流れ
1. 機械語
2. アセンブリ言語
3. 高級言語
4. 構造化プログラミング言語

### 機械語
コンピュータのみが理解することができる2進数で書かれた言語。  
初めの頃は人間が直接機械語を使って一行一行命令を記述していた。

### アセンブリ言語
機械語を更に発展させ、機械語を人間に理解することのできる記号に置き換えた言語。  
ADDやMOVなど単語単位で加算や移動を行っているのがわかる。

### 高級言語
機械語とアセンブリ言語ではコンピュータに一つひとつ実行命令を記述していたが、それをより分かりやすい形式で表現した言語。

### 不明な点
- FORTRAN

## 10
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

[構造化プログラミング \- Wikipedia](https://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)
### 第3章 P59～P61
OOP(オブジェクト指向プログラミング)を理解するにはプログラミング言語の歴史を知る必要がある。

### 構造化プログラミングとは
以前までのプログラミング言語ではGOTO文が多用されていて処理が飛び飛びになっていて可読性が非常に低かった。  
そのGOTO文を廃止し、基本三構造で分かり易く表現する手法のこと。GOTOレスプログラミングとも呼ばれる。

#### 基本三構造
1. 順次進行
2. 条件分岐
3. 繰り返し

### なぜ構造化前はGOTO文が多用されていたか
昔はPCスペックが低く、容量を圧迫しないようにロジックも短く記述する必要があった。そのためGOTO文などが多用されてスパゲッティコードが沢山生まれた。

### 注意点
1. オブジェクト指向
2. オブジェクト指向プログラム
3. オブジェクト指向プログラミング言語

1は考え方、2は書き方、3はオブジェクト指向が機能(継承やカプセル化など)として使用できる言語

## 11
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第3章 P61～P64
OOP(オブジェクト指向プログラミング)を理解するにはプログラミング言語の歴史を知る必要がある。

### 高級言語以降に生まれた技術
1. 構造化プログラミング
2. サブルーチン(関数)の独立

### なぜサブルーチンの独立性を高めるのか
構造化プログラミングはコードを分かりやすくするための手法。  
サブルーチンの独立性を高める目的はプログラムの保守をしやすくするため。

### サブルーチンの独立させる方法
まずプログラムには大きく分けてメインルーチンとサブルーチンがある。メインは呼び出し側のことでサブは関数などのこと。  
当時は複数のサブルーチンから共通のグローバル変数を使用していて、どのサブルーチンがグローバル変数に変更を加えたのか理解し辛く、意図しない他関数の代入などで不具合が発生した。  
このことから呼び出し側と関数の共有する情報を少なくする方法が必要になり、ローカル変数と引数の値渡しが生まれた。
ローカル変数は関数に入ったときに生まれて内部で使用されて関数を抜けるときに消える。
引数の値渡しは呼び出し側の参照している値を直接使用しないで、コピーして関数で使用する

## 12
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第3章 P64～P65
OOP(オブジェクト指向プログラミング)を理解するにはプログラミング言語の歴史を知る必要がある。

### 構造化言語の登場
構造化プログラムを作成するための機能が基本機能として備わっている標準化言語が登場した。if、case、while、forなどを使って上から下へ処理の分岐などを行って分かりやすいコードを作ることができるようになった。

### 構造化言語の種類
1. ALGOL
2. Pascal
3. C言語

### 不明な点
- C言語の特徴
- プログラミングに必要な機能を**言語仕様**で提供する言語、**関数ライブラリ**で提供する言語

## 15
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第3章 P65～P71
OOP(オブジェクト指向プログラミング)を理解するにはプログラミング言語の歴史を知る必要がある。

### プログラミング言語の進化の目的
機械語→アセンブリ言語→高級言語までの進化の目的は生産性を向上するさせ、20世紀には総人口がプログラマになっても生産が追いつかないというソフトウェア危機に対処するため。  
構造化言語はプログラムの保守性を高めて、毎回1からプログラムを作成するのではなく既存のプログラムを修正することで開発しやすくするのが目的。

### 構造化言語でも解決出来なかった問題
1. グローバル変数問題
2. 貧弱な再利用問題

#### グローバル変数問題
ローカル変数や値渡しを用いた構造化ではサブルーチンを抜けた場合に変数が消えてしまうので、サブルーチン外で常に持っておきたい値などはやむを得ずグローバル変数にするしかなかった。

#### 貧弱な再利用問題
共通部品化できるのはサブルーチンだけであったため、再利用できる範囲が狭かった。

### 不明な点
- 西暦2000年問題

## 16
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第4章 P77～P78
OOP(オブジェクト指向プログラミング)は無駄を省き、整理整頓するための書き方。

### OOPが持つ3つの仕組み
1. クラス
2. ポリモーフィズム
3. 継承

この仕組みは、グローバル変数を使わず、  
共通サブルーチン以外の再利用を可能にするために使用している。

### クラスの使用方法
主にカプセル化に使用される。  
カプセル化には内容を隠ぺいすることでセキュリティ面でプログラムを強化する側面と  
クラス内でクラス変数を持ち、外から触れない様にするなど  
責任範囲をクラス内に絞ることでこれまでグローバル変数で持っていた状態変数を扱うことができる。

## 17
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第4章 P78～P81
OOP(オブジェクト指向プログラミング)は無駄を省き、整理整頓するための書き方。

### ポリモーフィズムと継承
共通関数では対処できない重複コードを一つにまとめるためのもの。

### OOPの仕組みの狙い
共通部分はまとめて、何度も記述しないことでコードの文章量を減らし、  
入力ミスをなくす。カスタマイズしやすくする。

### クラスの3つの役割
1. サブルーチンと変数を「まとめる」
2. クラスの内部だけで使う変数やサブルーチンを「隠す」
3. 1つのクラスからインスタンスを「たくさん作る」

## 18
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第4章 P81～P84
OOP(オブジェクト指向プログラミング)は無駄を省き、整理整頓するための書き方。

### クラスを使ってサブルーチンと変数をまとめる
構造化プログラミングで記述したファイルアクセス処理
```java

// アクセス中のファイル番号を格納するグローバル変数
int fileNo;

// ファイルを開く
// (引数にパスを受け取る)
void openFile(String pathName){ /*ロジックは省略*/ }

// ファイルを閉じる
void closeFile(){ /*ロジックは省略*/ }

// ファイルを読み込む
char readFile(){ /*ロジックは省略*/ }

```

今までは構造化でサブルーチン(関数)単位でしか処理の整理ができなかったが、  
下記の図の様にクラスを使用することで複数のサブルーチンや変数もまとめることが出来るようになった。  

OOPで記述したファイルアクセス処理
```java

class TextFileReader {

  // アクセス中のファイル番号を格納するグローバル変数
  int fileNo;

  // ファイルを開く
  // (引数にパスを受け取る)
  void open(String pathName){ /*ロジックは省略*/ }

  // ファイルを閉じる
  void close(){ /*ロジックは省略*/ }

  // ファイルを読み込む
  char read(){ /*ロジックは省略*/ }
}

```
OOPでは  
クラスに内でのサブルーチンを**メソッド**と呼ぶ。  
クラスに内での変数は**インスタンス変数**と呼ぶ。

### 「まとめる」ことの利点
複数のサブルーチンをまとめることで部品が少なくなり、  
部品を探しているときに見つけやすくなる。

クラスでもってサブルーチンをまとめているので、  
クラス自体にどんな処理であるか名づけることができる。  
そのため事前にクラスが名前で持って処理の説明をしてくれているので、  
自然とクラス内に含まれるサブルーチン自体の名前も短くなる。

### 不明な点
- インスタンス
  - クラス(設計図)を元に生成される実体のこと。

- インスタンス変数
  - クラス内での変数をインスタンス変数と呼ぶ。

## 19
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第4章 P84～P86
OOP(オブジェクト指向プログラミング)は無駄を省き、整理整頓するための書き方。

### クラスの「隠す」役割とは
変数の使用箇所がクラス内のサブルーチンのみであった場合、  
変数をクラス内部だけで使用したい  
下記のコードではファイル番号を保持するインスタンス変数を内部だけで使用したいという状況。

```java
// 隠ぺい前
class TextFileReader {

  // アクセス中のファイル番号を格納するグローバル変数
  int fileNo;

  // ファイルを開く
  // (引数にパスを受け取る)
  void open(String pathName){ /*ロジックは省略*/ }

  // ファイルを閉じる
  void close(){ /*ロジックは省略*/ }

  // ファイルを読み込む
  char read(){ /*ロジックは省略*/ }
}
```


それをインスタンス変数の先頭にアクセス修飾子「private」を使用する。  
```java

  private int fileNo;
```
このように今までグローバル変数でどこからでもアクセスできてしまっていた変数を  
クラスの「隠す」仕組みを使用することで  
今回の様にファイル操作を行う共通の目的を持つサブルーチンからの  
使用に限定することで変数自体の型の変更や変数に意図しない値が入った際のデバッグがしやすくなる。

## 23
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第4章 P86～P91
OOP(オブジェクト指向プログラミング)は無駄を省き、整理整頓するための書き方。

### クラスの「たくさん作る」役割とは
インスタンスはクラスで定義したフィールドが確保されるメモリ領域とも言うことができる。  
そのためインスタンスを複数生成した際に、その数だけ別々のフィールドを持つことができる。
```Java
// TextFileReaderクラスから2つのインスタンスを作る
TextFileReader reader1 = new TextFileReader();
TextFileReader reader2 = new TextFileReader();

// 1番目のファイルを開く
reader1.open("C：\\aaa.txt");

// 2番目のファイルを開く
reader2.open("C：\\aaa.txt");

// 文字を読み込む変数の宣言
char ch;

// 1番目のファイルから1文字読み込む
ch = reader1.read();

// 2番目のファイルから1文字読み込む
ch = reader2.read();

// 1番目のファイルから1文字読み込む
ch = reader1.read();

// 1番目の2番目のファイルを閉じる
reader1.close();
reader2.close();
```
今まで関数の呼び出しの場合は関数名で判別できていたが、クラスを使用してフィールドとメソッドをまとめているため、  
どのインスタンスのメソッドであるかがわからないと呼び出せない。  
なので図のように  
**インスタンスを格納する変数.メソッド名**で呼び出す。  

このようなクラスを元にインスタンスを作成する仕組みを使用することで、  
クラスに記述するメソッドの内容は簡単になる。  
なぜかというと、使用される側のクラス内では、自分が複数同時に動作することなどを考えなくて良いため。

## 24, 25
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第4章 P91～P100
OOP(オブジェクト指向プログラミング)は無駄を省き、整理整頓するための書き方。

### OOPの仕組み2つ目「ポリモーフィズム」とは
1. クラス
2. **ポリモーフィズム**
3. 継承

ポリモーフィズムとは短く説明するとサブルーチンの呼び出し側を共通化すること。

ポリモーフィズムの目的は、  
同じ様な処理を持つ複数のクラスを使用した処理を何度も記述する避けることで  
コードを短く分かりやすくすること。

前回も説明に使用したテキストファイルを読み込むTextFileReaderクラスと  
新たにネットワーク経由で送信されたファイルを読む込むNetWorkReaderクラスを作成する。

```java
public class TextFileReader {

  // アクセス中のファイル番号を格納するフィールド
  int fileNo;

  // ファイルを開く
  // (引数にパスを受け取る)
  public void open(String pathName){ /*ロジックは省略*/ }

  // ファイルを閉じる
  public void close(){ /*ロジックは省略*/ }

  // ファイルを読み込む
  public char read(){ /*ロジックは省略*/ }
}
```
```java
public class NetWorkReader {

  // ファイルを開く
  // (引数にパスを受け取る)
  public void open(String pathName){ /*ロジックは省略*/ }

  // ファイルを閉じる
  public void close(){ /*ロジックは省略*/ }

  // ファイルを読み込む
  public char read(){ /*ロジックは省略*/ }
}
```
どちらもファイルも「開く」,「閉じる」,「読み込む」処理は共通しているため、  
ポリモーフィズムの考え方で、共通処理をスーパークラスにまとめることができる。

```java
// スーパークラス
public class TextReader {

  // ファイルを開く
  // (引数にパスを受け取る)
  public void open(String pathName){ /*ロジックは省略*/ }

  // ファイルを閉じる
  public void close(){ /*ロジックは省略*/ }

  // ファイルを読み込む
  public char read(){ /*ロジックは省略*/ }
}
```
TextReaderをスーパークラスとして、  
TextFileReaderクラスとNetWorkReaderクラスはサブクラスとしてTextReaderクラスを継承する。

```java
public class TextFileReader extends TextReader {
  // 省略
}

public class NetWorkReader extends TextReader {
  // 省略
}
```

すると以下に記述した。呼び出し側でサブクラスの共通の  
スーパークラスの型で、同じ呼び出し方で「テキストファイルの読み込み」と「ネットワーク経由で送信されたファイルの読む込む」を行って文字数を数えることができるようになる。

```java
// 呼び出し側
int getCount(TextReader reader) {

  // 文字数を格納用の変数
  int charCount = 0;

    While(true) {

      // ポリモーフィズムを使用して文字を読み込む
      char = reader.read();

      // 文字数をカウントアップ
      charCount++;
    }

// 文字数を返す
return charCount

}
```

## 26
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第4章 P100～P103
OOP(オブジェクト指向プログラミング)は無駄を省き、整理整頓するための書き方。

### OOPの仕組み3つ目「継承」とは
1. クラス
2. ポリモーフィズム
3. **継承**

継承とは共通機能をまとめ、コード重複の排除を目的としている。  

共通クラスをスーパークラス、それを継承して利用するクラスをサブクラスとすると  
サブクラスはスーパークラスのフィールドとメソッドを使用することができるようになる。

そうすることでサブクラス側には固有の処理だけを記述すれば良くなる。  
後から処理が追加されても、共通部分を継承したサブクラスを増やせば良い。  

コードに追加が発生しても増えるのはサブクラス、  
共通部分はクラスにまとめられているため既に動作の保証がとれている。  
つまりデバッグの必要範囲も狭まり、メンテナンス性も上がる。