# 2020/6

## 01
[C\# Linqを使ったら超便利だった\#1 \- Qiita](https://qiita.com/p1ro3/items/58da3f47975b301ae75f)

リストや配列に入ったデータの操作が容易になり、行数が減り、コード全体が見やすくなる。

リスト型変数
```c#
List<int> source = new List<int>() { 1, 2, 3, 4, 5, 6 };
```

変数内の要素を表示する(通常)
```c#
foreach(int num in source)
{
    Console.WriteLine(num);
}
```

変数内の要素を表示する(Linq)
```c#
source.ForEach(delegate (int num){ Console.WriteLine(num); });
```


ループを回さなくとも表示処理を一行で実行することが可能になる。

1. ForEach
  要素全てを探索する
2. Where
  一致するデータの抽出

### 不明な点
1. delegate

## 02
[【LINQの前に】ラムダ式？デリゲート？Func<T, TResult>？な人へのまとめ【知ってほしい】 \- Qiita](https://qiita.com/RyotaMurohoshi/items/740151bd772889cf07de)

### delegateとは
メソッドを参照するデータ型で、delegateを介してメソッドを引数として渡すことや返り値として返すことができる。  

### 重要な点
- delegateという機能
- 外からパラメーターとして処理を注入している。
- 中から外を呼び出している。

```c#
public static void Main(string[] args){
  var list = Enumerable.Range(1,10);
  var result = Pow2(list,logger)
}
public delegate void logger(int i){
  Console.WriteLine($"{i} x {i} = {i*i}");
}
public delegate void nullLogger(int i){
  //
}
public delegate void formLogger(int i){
  textBox1.Text += $"{i} x {i} = {i*i}";
}

// Action<T> : 戻り値がない
// Function<T,TResult> : 戻り値がTResult

public IEnumerable<int> Pow2(IEnumerable<int> list,Action<int> logger){
  var result = new List<int>();
  foreach (var i in list){
    result.Add(i*i);
    logger(i);
  }
  return result ;
}
```

----
```c#
public static void Main(string[] args){
  var list = Enumerable.Range(1,10);
  var result = Calc(list,divide3)
}
public int power(int i) {
  return i*i ;
}
public int divide3(int i) {
  return (int)(i/3) ;
}
public int double(int i) {
  return (int)(i*2) ;
}
// Action<sting,int,double,decimal> 
// Func<sting,int,double,decimal> 

public IEnumerable<int> Calc(IEnumerable<int> list,Func<int,int> calculator){
  var result = new List<int>();
  foreach (var i in list){
    result.Add(calculator(i));
  }
  return result ;
}

```
### 利点
上記のCalcメソッドのような一つの処理に外からメソッドを渡すことで  
共用することができ、長いコードを書く必要がなくなる。  
また、リストに対する計算機能が外にあるためCalcメソッドの信頼性を保ったまま、より短いコード量でカスタマイズが可能になる。

### 不明な点
1. クラスメソッドとインスタンスメソッドの違い

## 03
[【C\#】わかった"つもり"になれる「ラムダ式」解説 \- Qiita](https://qiita.com/toRisouP/items/98cc4966d392b7f21c30)

### ラムダ式とは
対象の関数をラムダ式に置き換えて記述を省略するためのもの。

(引数の変数) → {関数本体}  

上記の様に関数を定義を省略して内部の処理を実行することができる。

### 使用方法
ラムダ式で作った関数は必ずデリゲートに代入して使う

**いずれ記事修正を予定**

## 04
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第2章 P35～P38

### 理解した部分

現実世界 = オブジェクト指向ではない。

オブジェクト指向の基本はクラスでインスタンスはクラスの対となる要素となっている。  クラス(同種のものの集まり)を元にインスタンス(実例)を生成している。

### 不明な点
1. ポリモーフィズム
2. 

## 05
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第2章 P39～P42

### 理解した部分

``` java
class Animal {
  abstract String cry();
}
```
ポリモーフィズムの説明に使用されているJavaのabstractは抽象メソッドを使用するためのもの。  

ポリモーフィズムとはメッセージの送り方を共通にするためのもの。

### 継承
継承とはクラスの共通点をまとめたり、相違点を整理するためのもの。

- スーパークラス(全体集合)
- サブクラス(部分集合)

スーパークラスに共通処理を記述し、サブクラスには固有処理を記述する流れとなる。

### 不明な点
1. ポリモーフィズムの説明サンプルPGの動作  
   - 次回実際に作成して動作確認を予定

## 08
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第2章 P42～P49

### スーパークラスとサブクラス
スーパークラスとサブクラスは親と子の関係。  
子は親の機能を持っていて、子が独自に作り出した機能のことは親は知らない。

### ポリモーフィズム
ポリモーフィズム = 呼び出しかたを共通にする。  
大事なことは複数の対象の共通部を同じ呼び出し方で実装させたいという目的があって、ポリモーフィズムを使用しているということ。

### abstract
抽象クラスと抽象メソッドに使用するキーワード。  
自身のサブクラスが共通のメソッドを持っているという制約を持つという意味を持つ。  
持っていない場合はエラーとなる。

### 親と子の継承と型の関係
ある親を継承した場合に子は、親のクラス型であり子のクラス型でもあるという状態になる。  
共通の親クラスを持つ子クラスは**親クラス型の変数でインスタンスを受け取ることが出来る**  
この関係とabstractを使用したメソッドの抽象化で、メソッドの実装部をサブクラスで個別に行うことで呼出し方を同じにすることができる。

スーパークラス
```c#
    abstract class Animal
    {
        // 抽象メソッド(サブクラスで共通名のメソッドを使用するという制約をかける)
        public abstract string Cry();

        // クラス型表示用処理
        public string ClassName()
        {
            return this.GetType().Name;
        }

    }
```

サブクラス
```c#
    // Animalを継承した鳥の鳴き声を返すBirdクラス
    class Bird : Animal
    {
        public override string Cry()
        {
            return "ピヨピヨ";
        }
        public string Fly()
        {
            return "I can fly.";
        }

    }
    // Animalを継承した犬の鳴き声を返すDogクラス
    class Dog : Animal
    {
        public override string Cry()
        {
            return "ワン";
        }
    }
```

呼出し部分
```c#
            var seed = new Random().Next();
            Animal animal;

            // Birdクラスを元にインスタンスを生成する
            if (seed % 2 == 0)
            {
                animal = new Bird();
            }
            else
            {
                animal = new Dog();
            }

            // 鳴き声とクラスの表示
            Console.WriteLine(animal.ClassName());
            Console.WriteLine(animal.Cry());
            Console.ReadLine();
```
ランダムにseed変数に数字を入れて偶数は鳥、奇数は犬として分岐して鳴き声と自分のクラス型を表示する。  
BirdクラスとDogクラスは同じAnimalクラスを親に持っているため、Animal型で生成したインスタンスを受け取って共通メソッド実行することができる。


呼出し部分(親または子クラス型別にインスタンス生成ver)
``` c#
            // Birdクラスを元にインスタンスを生成する
            Bird bird = new Bird();
            bird.Fly();//1
            
            // Animalクラスを元にインスタンスを生成する
            Animal animal = new bird();
            animal.Fly(); //2

            // 鳴き声の表示
            Console.WriteLine(animal.Cry());
```
1の様に子自身のクラス型でインスタンスを受け取った場合は子独自のFlyメソッドを呼び出すことが可能です。  
2の様に親のクラス型でインスタンスを受け取った場合はFlyメソッド呼出しはエラーとなる。  
しかし、abstractを使用して共通化したメソッドは1と2どちらの場合でも実行することができる。

### なぜ何でもオブジェクトで例えるべきではないのか
オブジェクト指向ではモノは一つのクラスに属していて、それ以降変化することはない。しかし、現実世界のモノは見方や状況によって所属するクラスが変化する。そのためオブジェクト指向を正しく捉えるためには  
現実世界 = オブジェクト指向は控えるべきだ。

## 09
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

### 第3章 P55～P59
OOP(オブジェクト指向プログラミング言語)を理解するにはプログラミング言語の歴史を知る必要がある。

### OOPの生まれ
OOPは現実世界にそって生まれたのではなく、昔のプログラミング言語を発展させて欠点を克服した言語。

### プログラミング言語の進化の流れ
1. 機械語
2. アセンブリ言語
3. 高級言語
4. 構造化プログラミング言語

### 機械語
コンピュータのみが理解することができる2進数で書かれた言語。  
初めの頃は人間が直接機械語を使って一行一行命令を記述していた。

### アセンブリ言語
機械語を更に発展させ、機械語を人間に理解することのできる記号に置き換えた言語。  
ADDやMOVなど単語単位で加算や移動を行っているのがわかる。

### 高級言語
機械語とアセンブリ言語ではコンピュータに一つひとつ実行命令を記述していたが、それをより分かりやすい形式で表現した言語。

### 不明な点
- FORTRAN

## 10
[オブジェクト指向でなぜつくるのか 第2版 \| 平澤 章 \|本 \| 通販 \| Amazon](https://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A7%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E5%B9%B3%E6%BE%A4-%E7%AB%A0/dp/4822284654)

[構造化プログラミング \- Wikipedia](https://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)
### 第3章 P59～P61
OOP(オブジェクト指向プログラミング)を理解するにはプログラミング言語の歴史を知る必要がある。

### 構造化プログラミングとは
以前までのプログラミング言語ではGOTO文が多用されていて処理が飛び飛びになっていて可読性が非常に低かった。  
そのGOTO文を廃止し、基本三構造で分かり易く表現する手法のこと。GOTOレスプログラミングとも呼ばれる。

#### 基本三構造
1. 順次進行
2. 条件分岐
3. 繰り返し

### なぜ構造化前はGOTO文が多用されていたか
昔はPCスペックが低く、容量を圧迫しないようにロジックも短く記述する必要があった。そのためGOTO文などが多用されてスパゲッティコードが沢山生まれた。

### 注意点
1. オブジェクト指向
2. オブジェクト指向プログラム
3. オブジェクト指向プログラミング言語

1は考え方、2は書き方、3はオブジェクト指向が機能(継承やカプセル化など)として使用できる言語